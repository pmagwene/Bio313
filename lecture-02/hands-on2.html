<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Paul M. Magwene" />
  <meta name="date" content="07 September 2010" />
  <title> Scientific Computing for BiologistsHands-On Exercises, Lecture 2</title>
</head>
<body>
<div id="header">
<h1 class="title"> Scientific Computing for Biologists<br />Hands-On Exercises, Lecture 2</h1>
<h3 class="author">Paul M. Magwene</h3>
<h4 class="date">07 September 2010</h4>
</div>
<h1 id="vector-operations-in-r">Vector Operations in R</h1>
<p>As you saw last week R vectors support basic arithmetic operations that correspond to the same operations on geometric vectors. For example:</p>
<pre><code>&gt; x &lt;- 1:15
&gt; y &lt;- 10:24
&gt; x + y             # vector addition
 [1] 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39
&gt; x - y             # vector subtraction
 [1] -9 -9 -9 -9 -9 -9 -9 -9 -9 -9 -9 -9 -9 -9 -9
&gt; x * 3             # multiplication by a scalar
 [1]  3  6  9 12 15 18 21 24 27 30 33 36 39 42 45 
</code></pre>
<p>R also has an operator for the dot product, denoted <code>%*%</code>. This operator also designates matrix multiplication, which we will discuss next week. By default this operator returns an object of the R matrix class. If you want a scalar (or the R equivalent of a scalar, i.e. a vector of length 1) you need to use the <code>drop()</code> function.</p>
<pre><code>&gt; z &lt;- x %*% x
&gt; class(z)      # note use of class() function
[1] &quot;matrix&quot;
&gt; z
     [,1]
[1,] 1240
&gt; drop(z)
[1] 1240
</code></pre>
<blockquote>
<p>In R, use the dot product operator and the <code>acos()</code> function to calculate the angle (in radians) between the vectors <img src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cvec%7Bx%7D%20%3D%20%5B-3%2C%20-3%2C%20-1%2C%20-1%2C%200%2C%200%2C%201%2C%202%2C%202%2C%203%5D%27" alt="\vec{x} = [-3, -3, -1, -1, 0, 0, 1, 2, 2, 3]'" title="\vec{x} = [-3, -3, -1, -1, 0, 0, 1, 2, 2, 3]'" /> and <img src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cvec%7By%7D%20%3D%20%5B-8%2C%20-5%2C%20-3%2C%200%2C%20-1%2C%200%2C%205%2C%201%2C%206%2C%205%5D%27" alt="\vec{y} = [-8, -5, -3, 0, -1, 0, 5, 1, 6, 5]'" title="\vec{y} = [-8, -5, -3, 0, -1, 0, 5, 1, 6, 5]'" />. Remember that <img src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%20%5Cvec%7Bx%7D%20%5Ccdot%20%5Cvec%7By%7D%20%3D%20%20%7C%5Cvec%7Bx%7D%7C%7C%5Cvec%7By%7D%7C%20%5Ccos%20%5Ctheta%20" alt=" \vec{x} \cdot \vec{y} =  |\vec{x}||\vec{y}| \cos \theta " title=" \vec{x} \cdot \vec{y} =  |\vec{x}||\vec{y}| \cos \theta " />.</p>
</blockquote>
<h1 id="vector-operations-in-python">Vector Operations in Python</h1>
<p>The Python equivalent of the R code above is:</p>
<pre><code>&gt;&gt;&gt; import numpy
&gt;&gt;&gt; x = numpy.arange(start=1, stop=16, step=1)
&gt;&gt;&gt; y = numpy.arange(10,25) # default step = 1
&gt;&gt;&gt; x
array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15])
&gt;&gt;&gt; y
array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24])
&gt;&gt;&gt; x+y
array([11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39])
&gt;&gt;&gt; x-y
array([-9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9])
&gt;&gt;&gt; 3*x
array([ 3,  6,  9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45])
&gt;&gt;&gt; z = numpy.dot(x,x) # no built-indot operator, but a dot function in numpy
&gt;&gt;&gt; z
1240
</code></pre>
<p>Note the use of the <code>numpy.arange()</code> function. <code>numpy.arange()</code> works like R’s <code>sequence()</code> function and it returns a Numpy array. However, notice that the values go up to but don’t include the specified <code>stop</code> value. Use <code>help()</code> to lookup the documentation for <code>numpy.arange()</code>. Python also includes a <code>range()</code> function that generates a regular sequence as a Python list object. The <code>range()</code> function has <code>start</code>, <code>stop</code>, and <code>step</code> arguments but these can only be integers. Here are some additional examples of the use of <code>arange()</code> and <code>range()</code>:</p>
<pre><code>&gt;&gt;&gt; z = numpy.arange(1,5,0.5) 
&gt;&gt;&gt; z
array([ 1. ,  1.5,  2. ,  2.5,  3. ,  3.5,  4. ,  4.5])
&gt;&gt;&gt; range(1,20,2)
[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
&gt;&gt;&gt; range(1,5,0.5)
__main__:1: DeprecationWarning: integer argument expected, got float
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ValueError: range() step argument must not be zero
</code></pre>
<h1 id="writing-functions-in-r">Writing Functions in R</h1>
<p>So far we’ve been using R’s built in functions. However the power of a true programming language is the ability to write your own functions.</p>
<p>The general form of an R function is as follows:</p>
<pre><code>funcname &lt;- function(arg1, arg2) {
 # one or more expressions
 # last expression is the object returned
}
</code></pre>
<p>To make this concrete, here’s an example where we define a function in the interpreter and then put it to use:</p>
<pre><code>&gt; myfunc &lt;- function(x,y){
+   x^2 + y^2     # don't type the '+' symbols, these show continuation lines
+ }

&gt; a &lt;- 1:5
&gt; b &lt;- 6:10
&gt; a
[1] 1 2 3 4 5
&gt; b
[1]  6  7  8  9 10
&gt; myfunc(a,b)
[1]  37  53  73  97 125
&gt; myfunc
function(x,y){
  x^2 + y^2
}
</code></pre>
<p>If you type a function name without parentheses R shows you the function’s definition. This works for built-in functions as well (thought sometimes these functions are defined in C code in which case R will tell you that the function is a ‘.Primitive’).</p>
<h2 id="putting-r-functions-in-scripts">Putting R functions in Scripts</h2>
<p>When you define a function at the interactive prompt and then close the interpreter your function definition will be lost. The simple way around this is to define your R functions in a script that you can than access at any time.</p>
<p>Choose <code>File &gt; New Script</code> (or <code>New Document</code> in OS X) in the R GUI. This will bring up a blank editor window. Enter your function into the editor and save the source file in your R working directory with a name like <code>vecgeom.R</code>.</p>
<pre><code># functions defined in vecgeom.R

veclength &lt;- function(x) {
  # Given a numeric vector, returns length of that vector
  sqrt(drop(x %*% x))
}

unitvector &lt;- function(x) {
  # Given a numeric vector, returns a unit vector in the same direction
  x/veclength(x)
}
</code></pre>
<p>There are two functions defined above, one of which calls the other. Both take single vector arguments. At this point there is no error checking to insure that the argument is reasonable but R’s built in error handling will do just fine for now.</p>
<p>Once your functions are in a script file you can make them accesible by using the <code>source()</code> function (See also the <code>File &gt; Source R code...</code> menu item):</p>
<pre><code>&gt; source(&quot;vecgeom.R&quot;)
&gt; x = c(-3,-3,-1,-1,0,0,1,2,2,3)
&gt; veclength(x)
[1] 6.164414
&gt; ux &lt;- unitvector(x)
&gt; ux
 [1] -0.4866643 -0.4866643 -0.1622214 -0.1622214  0.0000000  0.0000000
 [7]  0.1622214  0.3244428  0.3244428  0.4866643
</code></pre>
<blockquote>
<p>Write a function in R that takes two vectors, <img src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cvec%7Bx%7D" alt="\vec{x}" title="\vec{x}" /> and <img src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cvec%7By%7D" alt="\vec{y}" title="\vec{y}" />, and returns a list containing the projection of <img src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cvec%7By%7D" alt="\vec{y}" title="\vec{y}" /> on <img src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cvec%7Bx%7D" alt="\vec{x}" title="\vec{x}" /> and the component of <img src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cvec%7By%7D" alt="\vec{y}" title="\vec{y}" /> in <img src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cvec%7Bx%7D" alt="\vec{x}" title="\vec{x}" />: <br /><img src="http://chart.apis.google.com/chart?cht=tx&amp;chl=P_%7B%5Cvec%7Bx%7D%7D%28%5Cvec%7By%7D%29%20%3D%20%5Cleft%28%5Cfrac%7B%5Cvec%7Bx%7D%20%5Ccdot%20%5Cvec%7By%7D%7D%7B%7C%5Cvec%7Bx%7D%7C%7D%5Cright%29%20%5Cfrac%7B%5Cvec%7Bx%7D%7D%7B%7C%5Cvec%7Bx%7D%7C%7D%0A" alt="P_{\vec{x}}(\vec{y}) = \left(\frac{\vec{x} \cdot \vec{y}}{|\vec{x}|}\right) \frac{\vec{x}}{|\vec{x}|}
" title="P_{\vec{x}}(\vec{y}) = \left(\frac{\vec{x} \cdot \vec{y}}{|\vec{x}|}\right) \frac{\vec{x}}{|\vec{x}|}
" /><br /></p>
<p><br /><img src="http://chart.apis.google.com/chart?cht=tx&amp;chl=C_%7B%5Cvec%7Bx%7D%7D%28%5Cvec%7By%7D%29%20%3D%20%5Cfrac%7B%5Cvec%7Bx%7D%20%5Ccdot%20%5Cvec%7By%7D%7D%7B%7C%5Cvec%7Bx%7D%7C%7D%20%0A" alt="C_{\vec{x}}(\vec{y}) = \frac{\vec{x} \cdot \vec{y}}{|\vec{x}|} 
" title="C_{\vec{x}}(\vec{y}) = \frac{\vec{x} \cdot \vec{y}}{|\vec{x}|} 
" /><br /></p>
</blockquote>
<h1 id="writing-functions-in-python">Writing Functions in Python</h1>
<p>The general form of a Python function is as follows:</p>
<pre><code>def funcname(arg1,arg2):
    # one or more expressions
    return someresult # arbitrary python object (could even be another function)
</code></pre>
<p>An important thing to remember when writing functions is that Python is white space sensitive. In Python code indentation indicates scoping rather than braces. Therefore you need to maintain consistent indendation. This may surprise those of you who have extensive programming experience in another language. However, white space sensitivity contributes signficantly to the readability of Python code. Use a Python aware programmer’s editor and it will become second nature to you after a short while. I recommend you set your editor to substitute spaces for tabs (4 spaces per tab), as this is the default convention within the python community.</p>
<p>Here’s an example of defining and using a function in the Python interpreter:</p>
<pre><code>&gt;&gt;&gt; def mypyfunc(x,y):
    return x**2 + y**2 + 3*x*y

&gt;&gt;&gt; mypyfunc(10,12)
604
&gt;&gt;&gt; a = numpy.arange(1,5,0.5)
&gt;&gt;&gt; b = numpy.arange(2,6,0.5)
&gt;&gt;&gt; mypyfunc(a,b)
array([  11.  ,   19.75,   31.  ,   44.75,   61.  ,   79.75,  101.  ,  124.75])
&gt;&gt;&gt; a = range(1,5)
&gt;&gt;&gt; b = range(1,5)
&gt;&gt;&gt; mypyfunc(a,b)

Traceback (most recent call last):
  File &quot;&lt;pyshell#52&gt;&quot;, line 1, in -toplevel-
    mypyfunc(a,b)
  File &quot;&lt;pyshell#45&gt;&quot;, line 2, in mypyfunc
    return x**2 + y**2 + 3*x*y
TypeError: unsupported operand type(s) for ** or pow(): 'list' and 'int'
&gt;&gt;&gt; 
</code></pre>
<p>Note that this function works for numeric types (<code>ints</code> and <code>floats</code>) as well as <code>numpy.arrays</code> but not for simple Python lists. If you wanted to make this function work for lists as well you could define the function as follows:</p>
<pre><code>&gt;&gt;&gt; def mypyfunc(x,y):
    x = numpy.array(x)  # local scope
    y = numpy.array(y)
    return x**2 + y**2 + 3*x*y

&gt;&gt;&gt; a
[1, 2, 3, 4]
&gt;&gt;&gt; b
[1, 2, 3, 4]
&gt;&gt;&gt; mypyfunc(a,b)
array([ 5, 20, 45, 80])
</code></pre>
<h2 id="putting-python-functions-in-modules">Putting Python functions in Modules</h2>
<p>As with R, you can define your own Python modules that contain user defined functions. In the IDLE GUI choose <code>File &gt; New Window</code> which will bring up an editor window. Enter your function and save it to a file with a <code>.py</code> extension in a directory in your PYTHONPATH.</p>
<pre><code># functions defined in vecgeom.py
import numpy

def veclength(x):
    &quot;&quot;&quot;Given a numeric vector, returns length of that vector&quot;&quot;&quot; 
    x = numpy.array(x)
    return numpy.sqrt(numpy.dot(x,x))
    

def unitvector(x):
    &quot;&quot;&quot;Given a numeric vector, returns a unit vector in the same direction&quot;&quot;&quot;
    x = numpy.array(x)
    return x/veclength(x)
</code></pre>
<p>To access your function use an <code>import</code> statement:</p>
<pre><code>&gt;&gt;&gt; import vecgeom
&gt;&gt;&gt; x = [-3,-3,-1,-1,0,0,1,2,2,3]
&gt;&gt;&gt; help(vecgeom.veclength)
Help on function veclength in module vecgeom:

veclength(x)
    Given a numeric vector, returns length of that vector

&gt;&gt;&gt; vecgeom.veclength(x)
6.164414002968976
&gt;&gt;&gt; from vecgeom import * # import all functions from the vecgeom module
&gt;&gt;&gt; print unitvector(x)
[-0.48666426 -0.48666426 -0.16222142 -0.16222142  0.          0.   
     0.16222142  0.32444284  0.32444284  0.48666426]
</code></pre>
<blockquote>
<p>Write Python code for the vector projection and component functions as described above. In your Pweave document illustrate the use of these functions with several examples. Submit your module, <code>vecgeom.py</code> as a separate code file. Remember that your module will need to have access to the <code>numpy</code> module so include an appropriate <code>import</code> statement.</p>
</blockquote>
<h1 id="dealing-with-data-subsets-in-r">Dealing with Data Subsets in R</h1>
<p>Manipulating or analyzing subsets of data is one of the most common tasks in R. The <code>subset()</code> function comes in handy for such operations. Consider the data set <code>turtles.txt</code>:</p>
<pre><code>&gt; turtles &lt;- read.table('turtles.txt', header=T)
&gt; turtles
   sex length width height
1    f     98    81     38
2    f    103    84     38
3    f    103    86     42
  # output truncated
&gt; names(turtles)
[1] &quot;sex&quot;    &quot;length&quot; &quot;width&quot;  &quot;height&quot;
&gt;
&gt; # Now we'll apply the subset() function
&gt;
&gt; turt.sub &lt;- subset(turtles, select = -sex)
&gt; names(turt.sub)
[1] &quot;length&quot; &quot;width&quot;  &quot;height&quot;
&gt; turt.sub
   length width height
1      98    81     38
2     103    84     38
3     103    86     42
  # output truncated
</code></pre>
<p>In the example above we create a subset of the original data set by excluding the variable indicating the sex of each individual using the argument <code>select = -sex</code>. We can also explicit include only certain variables, like this:</p>
<pre><code>&gt; turt.sub2 &lt;- subset(turtles, select=c(height,width))
&gt; turt.sub2
   height width
1      38    81
2      38    84
3      42    86
  # output truncated    
</code></pre>
<p><code>subset()</code> allows you to do more than just select variables to include. You can use the second positional argument to specify matching criteria. For example:</p>
<pre><code># gives only female turtles, all variables except sex
&gt; female.turts &lt;- subset(turtles, sex == &quot;f&quot;, select = -sex)
&gt; dim(female.turts)
[1] 24  3

# same for male turtles
&gt; male.turts &lt;- subset(turtles, sex == &quot;m&quot;, select = -sex)
&gt; dim(male.turts)
[1] 24  3

# gives only females with length &gt; 125, all variables
&gt; big.females &lt;- subset(turtles, sex == &quot;f&quot; &amp; length &gt; 125)    
</code></pre>
<p>The <code>subset</code> function is especially useful when combined with the function <code>sapply()</code> which allows you to apply a function of interest to each variable. For example:</p>
<pre><code>&gt; min(turtles)
Error in Summary.data.frame(..., na.rm = na.rm) : 
        only defined on a data frame with all numeric or complex variables
&gt; min(turt.sub)  # unexpected result
[1] 35
&gt; sapply(turt.sub, min) # here's what we were shooting for
length  width height 
    93     74     35
&gt; sapply(female.turts, min) # for females
length  width height 
    98     81     38 
&gt; sapply(male.turts, min) # for males
length  width height 
    93     74     35      
</code></pre>
<p>Notice how the <code>min()</code> function chokes on the complete data set because the function is not definited for factor variables. In the second example <code>min(turt.sub)</code> returns a valid result, but also not exactly what we wanted. In this case it looked for the minimum value across all the objects passed to it. In the third case we use the <code>sapply()</code> function and get the minimum on a variable-by-variable basis. Please take a moment to look at the documentation for the <code>sapply()</code> function and cook up some examples of your own.</p>
<blockquote>
<p>Calculate a summary table as well as correlation and covariance matrices for the <code>turtles.txt</code> data set. Use <code>help.search()</code> and <code>apropos()</code> to lookup any necessary function names. Repeat the calculation of the correlation and covariance matrices separately for female and male turtles.</p>
</blockquote>
<h1 id="exploring-univariate-distributions-in-r">Exploring Univariate Distributions in R</h1>
<h2 id="histograms">Histograms</h2>
<p>One of the most common ways to examine a the distribution of observations for a single variable is to use a histogram. The <code>hist()</code> function creates simple histograms in R.</p>
<pre><code>&gt; hist(turtles$length) # create histogram with fxn defaults
&gt; ?hist # check out the documentation on hist
</code></pre>
<p>Note that by default the <code>hist()</code> function plots the frequencies in each bin. If you want the probability densities instead set the argument <code>freq=FALSE</code>.</p>
<pre><code>&gt; hist(turtles$length,freq=F) # y-axis gives probability density
</code></pre>
<p>Here’s some other ways to fine tune a histogram in R.</p>
<pre><code>&gt; hist(turtles$length, breaks=8) # use 8 bins
&gt; mybreaks = seq(85,185,8)
&gt; hist(turtles$length, breaks=mybreaks) # specify bin boundaries   
&gt; hist(turtles$length, col='red') # fill the bins with red  
</code></pre>
<h2 id="density-plots">Density Plots</h2>
<p>One of the problems with histograms is that they can be very sensitive to the size of the bins and the break points used. This is due to the discretization inherent in a histogram. A ‘density plot’ or ‘density trace’ is a continuous estimate of a probability distribution from a set of observations. Because it is continuous it doesn’t suffer from the same sensitivity to bin sizes and break points. One way to think about a density plot is as the histogram you’d get if you averaged many individual histograms each with slightly different breakpoints.</p>
<pre><code>&gt; d &lt;- density(turtles$length)
&gt; plot(d)    
</code></pre>
<p>A density plot isn’t entirely parameter free – the parameter you should be most aware of is the ‘smoothing bandwidth’.</p>
<pre><code>&gt; d &lt;- density(turtles$length) # let R pick the bandwidth
&gt; plot(d,ylim=c(0,0.020)) # gives ourselves some extra headroom on y-axis
&gt; d2 &lt;- density(turtles$length, bw=5) # specify bandwidth
&gt; lines(d2, col='red') # use lines to draw over previous plot
</code></pre>
<p>The bandwidth determines the standard deviation of the ‘kernel’ that is used to calculate the density plot. There are a number of different types of kernels you can use; a Gaussian kernel is the R default and is the most common choice. See the documentation for more info.</p>
<p>The <code>lattice</code> package is an R library that makes it easier to create graphics that show conditional distributions. Here’s how to create a simple density plot using the <code>lattice</code> package.</p>
<pre><code>&gt; library(lattice)
&gt; densityplot(turtles$length)    
</code></pre>
<p>Notice how by default the <code>lattice</code> package also drew points representing the observations along the x-axis. These points have been ‘jittered’ meaning they’ve been randomly shifted by a small amount so that overlapping points don’t completely hid each other. We could have produced a similar plot, without the lattice package, as so:</p>
<pre><code>&gt; d &lt;- density(turtles$length)
&gt; plot(d)
&gt; nobs &lt;- length(turtles$length)
&gt; points(jitter(turtles$length), rep(0,nobs)) 
</code></pre>
<p>Notice that in our version we only jittered the points along the x-axis. You can also combine a histogram and density trace, like so:</p>
<pre><code>&gt; hist(turtles$length, 10, xlab='Carapace Length (mm)',probability=T)
&gt; d &lt;- density(turtles$length)
&gt; lines(d, col='red', lwd=2) # red lines, with pixel width 2    
</code></pre>
<p>Notice the use of the <code>probability=T</code> argument to scale the histogram bars in terms of probability density.</p>
<p>Finally, let’s some of the features of <code>lattice</code> to produce density plots for the ‘length’ variable of the turtle data set, conditional on sex of the specimen.</p>
<pre><code>&gt; densityplot(~length | sex, data = turtles)    
</code></pre>
<p>There are a number of new concepts here. The first is that we used what is called a ‘formula’ to specify what to plot. In this case the formula can be read as ‘length conditional on sex’. We’ll be using formulas in several other contexts and we discuss them at greater length below. The <code>data</code> argument allows us to specify a data frame or list so that we don’t always have to write arguments like <code>turtles$length</code> or <code>turtles$sex</code> which can get a bit tedious.</p>
<h2 id="box-plots">Box Plots</h2>
<p>Another common tool for depicting a univariate distribution is a ‘box plot’ (sometimes called a box-and-whisker plot). A standard box plot depicts five useful features of a set of observations: the median (center most line), the upper and lower quartiles (top and bottom of the box), and the minimum and maximum observations (ends of the whiskers).</p>
<blockquote>
<p><img src="boxplot-labeled.png" alt="image" /> {A box plot graphical represents a five number summary of a set of observations.}</p>
</blockquote>
<p>There are many variants on box plots, particular with respect to the ‘whiskers’. It’s always a good idea to be explicit about what a box plot you’ve created depicts.</p>
<p>Here’s how to create box plots using the standard R functions as well as the lattice package:</p>
<pre><code>&gt; boxplot(turtles$length)
&gt; boxplot(turtles$length, col='darkred', horizontal=T) # horizontal version 
&gt; title(main = 'Box plot: Carapace Length', ylab = 'Carapace length (mm)')
&gt; bwplot(~length,data=turtles) # using the bwplot function from lattice
</code></pre>
<p>Note how we used the <code>title()</code> function to change the axis labels and add a plot title.</p>
<h4 id="historical-note">Historical note</h4>
<p>– the box plot is one of many inventions of the statistician John W. Tukey. Tukey made many contributions to the field of statistics and computer science, particularly in the areas of graphical representations of data and exploratory data analysis.</p>
<h2 id="bean-plots">Bean Plots</h2>
<p>My personal favorite way to depict univariate distributions is called a ‘beanplot’. Beanplots combine features of density plots and boxplots and provide information rich graphical summaries of single variables. The standard features in a beanplot include the individual observations (depicted as lines), the density trace estimated from the observations, the mean of the observations, and in the case of multiple beanplots an overall mean.</p>
<blockquote>
<p><img src="beanplot-labeled.png" alt="image" /> {Beanplots combine features of a density plot and a box plot.}</p>
</blockquote>
<p>The <code>beanplot</code> package is not installed by default. To download it and install it use the R package installer under the <code>Packages &amp; Data</code> menu. If this is the first time you use the package installer you’ll have to choose a CRAN repository from which to download package info (I recommend you pick one in the US). Once you’ve done so you can search for ‘beanplot’ from the Package Installer window. You should also check the ’install dependencies’ check box.</p>
<p>Once the beanplot package has been installed check out the examples to see some of the capabilities:</p>
<pre><code>&gt; library(beanplot) 
&gt; example(beanplot)    
</code></pre>
<p>Note the use of the <code>library()</code> function to make the functions in the <code>beanplot</code> library available for use. Here’s some examples of using the <code>beanplot</code> function with the turtle data set:</p>
<pre><code>&gt; beanplot(turtles$length) # note the message about log='y'
&gt; beanplot(turtles$length, log='') # DON'T do the automatic log transform
&gt; beanplot(turtles$length, log='', col=c('white','blue','blue','red'))
</code></pre>
<p>In the final version we specified colors for the parts of the beanplot. See the explanation of the <code>col</code> argument int he beanplot function for details.</p>
<p>We can also compare the carapace length variable for male and female turtles.</p>
<pre><code>&gt; beanplot(length ~ sex, data = turtles, col=list(c('red'),c('black')),
+ names = c('females','males'),xlab='Sex', ylab='Caparace length (mm)')
</code></pre>
<p>Note the use of the formula notation to compare the carapace length variable for males and females. There is also a asymmetrical version of the beanplot which can be used to more directly compare distributions between two groups. We explore this below. Note too the use of the list argument to <code>col</code>, and the use of vectors within the list to specify the colors for female and male beanplots.</p>
<p>We can also create a beanplot with multiple variables in the same plot if the variables are measured on the same scale.</p>
<pre><code>&gt; beanplot(turtles$length, turtles$width, turtles$height, log='',
names=c('length','width','height'), ylab='carapace dimensions (mm)') 
</code></pre>
<h2 id="simple-t-tests-in-r">Simple t-tests in R</h2>
<p>Student’s t-tests can be carried out in R using the function <code>t.test()</code>. The <code>t.test()</code> function can perform one and two-sample t-tests (i.e. comparing a sample of interest against a hypothesized mean, or comparing the means of two samples). The <code>t.test()</code> function also supports a ‘formula’ interface for two-sample t-tests similar to the <code>lm(</code>) function.</p>
<pre><code>&gt; t.test(width ~ sex, data=turtles)

        Welch Two Sample t-test

data:  width by sex 
t = 4.7015, df = 35.355, p-value = 3.862e-05
alternative hypothesis: true difference in means is not equal to 0 
95 percent confidence interval:
  8.122699 20.460634 
sample estimates:
mean in group f mean in group m 
      102.58333        88.29167 
</code></pre>
<p>The asymmetric version of the boxplot is very useful for comparing distributions of the same variable between two groups. To generate such plots use the argument <code>side='both'</code> as an argument to <code>beanplot</code>.</p>
<pre><code>&gt; beanplot(width ~ sex, data = turtles, side='both', col=list(c('red'),c('black')))  
</code></pre>
<p>As you can see this splits the beanplot in half for each group and puts them back to back to facilitate comparison. The difference in the mean of the two groups is visually obvious from the beanplot.</p>
<blockquote>
<ul>
<li><p>Prepare beanplots showing individuals grouped by sex for each of the quantitative variables in the <code>turtles.txt</code> data set. Label the x- and y-axes of your boxplots and give each plot a title. Use the <code>File &gt; Save as... &gt; PDF</code> menu to save your figures.</p></li>
<li><p>Carry out two-sample t-tests for the length and height variables, comparing male and female turtles.</p></li>
<li><p>Write a brief paragraph interpreting the results of the t-tests you carried out.</p></li>
</ul>
</blockquote>
<h1 id="exploring-bivariate-distributions-in-r">Exploring Bivariate Distributions in R</h1>
<h1 id="scatterplots">Scatterplots</h1>
<p>When dealing with pairs of continuous variables a scatter plot is the obvious choice. The standard <code>plot</code> function can be used:</p>
<pre><code>&gt; plot(turtles$length, turtles$width)
&gt; plot(turtles$length ~ turtles$width)    
</code></pre>
<p>Did you notice what is different between the two versions above? You can also use the <code>data</code> argument with plot, like so:</p>
<pre><code>&gt; plot(length ~ width, data=turtles)
</code></pre>
<p>The <code>xyplot()</code> function from the <code>lattice</code> package does pretty much the same thing:</p>
<pre><code>&gt; xyplot(length ~ width, data = turtles)
</code></pre>
<h1 id="regression-in-r">Regression in R</h1>
<p>R has very flexible built in functions for fitting linear models. Bivariate regression is the simplest case of a linear model.</p>
<pre><code>&gt; turtles &lt;- read.table('turtles.txt',header=T)
&gt; names(turtles)
[1] &quot;sex&quot;    &quot;length&quot; &quot;width&quot;  &quot;height&quot;
&gt; regr &lt;- lm(turtles$width ~ turtles$length)
&gt; class(regr)
[1] &quot;lm&quot;
&gt; names(regr)
 [1] &quot;coefficients&quot;  &quot;residuals&quot;     &quot;effects&quot;       &quot;rank&quot;          &quot;fitted.values&quot;
 [6] &quot;assign&quot;        &quot;qr&quot;            &quot;df.residual&quot;   &quot;xlevels&quot;       &quot;call&quot;         
[11] &quot;terms&quot;         &quot;model&quot;   
&gt; summary(regr)

Call:
lm(formula = turtles$width ~ turtles$length)

Residuals:
     Min       1Q   Median       3Q      Max 
-5.57976 -1.66578 -0.04471  1.73752  5.97104 

Coefficients:
               Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept)     19.9434     2.3877   8.353 8.99e-11 ***
turtles$length   0.6055     0.0189  32.033  &lt; 2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 

Residual standard error: 2.654 on 46 degrees of freedom
Multiple R-Squared: 0.9571,     Adjusted R-squared: 0.9562 
F-statistic:  1026 on 1 and 46 DF,  p-value: &lt; 2.2e-16 

&gt; plot(turtles$width ~ turtles$length)  # scatter plot with turtles$length on x axis
&gt; abline(regr)  # plot the regression line
</code></pre>
<p>Note the use of the function <code>abline()</code> to plot the regression line. Calling <code>plot()</code> with an object of class “<code>lm</code>” shows a series of diagnostic plots.</p>
<blockquote>
<p>Write your own regression function (i.e. your code shouldn’t refer to the built in regression functions) for mean centered vectors in R. The function will take as it’s input two vectors, <img src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cvec%7Bx%7D" alt="\vec{x}" title="\vec{x}" /> and <img src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cvec%7By%7D" alt="\vec{y}" title="\vec{y}" />. The function should return:</p>
<ol>
<li><p>a list containing the mean-centered versions of these vectors</p></li>
<li><p>the regression coefficient <img src="http://chart.apis.google.com/chart?cht=tx&amp;chl=b" alt="b" title="b" /> in the mean centered regression equation <img src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cvec%7B%5Cwidehat%7By%7D%7D%20%3D%20b%5Cvec%7Bx%7D" alt="\vec{\widehat{y}} = b\vec{x}" title="\vec{\widehat{y}} = b\vec{x}" /></p></li>
<li><p>the coefficient of determination, <img src="http://chart.apis.google.com/chart?cht=tx&amp;chl=R%5E2" alt="R^2" title="R^2" /></p></li>
</ol>
<p>Illustrate the use of your regression function for a data set of your choosing.</p>
</blockquote>
</body>
</html>
